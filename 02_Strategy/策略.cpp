/*************************************************************
	2.策略模式

定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，
从而使它们可以相互替换 & 让算法可在不影响客户端的情况下发生变化

简单来说：准备一组算法 & 将每一个算法封装起来，让外部按需调用

将算法的责任和本身进行解耦，使得：
	算法可独立于使用外部而变化
	客户端方便根据外部条件选择不同策略来解决不同问题
	策略模式仅仅封装算法（包括添加 & 删除），但策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定

=================================实例======================================
背景：小成有一家百货公司，最近在定年度的促销活动
冲突：每个节日用同一个促销活动太枯燥，没吸引力
解决方案：针对不同节目使用不同促销活动进行促销

=================================步骤======================================
步骤1：定义抽象策略角色（Strategy）：百货公司所有促销活动的共同接口
步骤2：定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动
步骤3：定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员
步骤4：客户端调用-让销售员进行促销活动的落地

=================================优点=======================================
策略类之间可以自由切换
	由于策略类都实现同一个接口，所以使它们之间可以自由切换
易于扩展
	增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则”（扩展开放，修改关闭）
避免使用多重条件选择语句（if else），充分体现面向对象设计思想。

=================================缺点=======================================
	客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
	将造成产生很多策略类（可以通过使用享元模式在一定程度上减少对象的数量）。

*************************************************************/

#include <iostream>
#include "Context.h"
using namespace std;

/*
//步骤4：客户端调用-让销售员进行促销活动的落地
void Client()
{
	Context_SalesMan mSalesMan;

	//春节来了，使用春节促销活动
	cout << "春节：";
	mSalesMan.SalesMan(FestivalSpring);
	mSalesMan.SalesManShow();

	//中秋节来了，使用中秋节促销活动
	cout << "中秋节：";
	mSalesMan.SalesMan(FestivalMidautumn);
	mSalesMan.SalesManShow();

	//端午节来了，使用圣诞节促销活动
	cout << "端午节：";
	mSalesMan.SalesMan(FestivalDragonBoat);
	mSalesMan.SalesManShow();
}
*/

int main()
{
//	Client();
	Context_Waiter waiter;

	//春节来了，使用春节促销活动
	cout << "甲国人：";
	waiter.Waiter(CountryJia);
	waiter.WaiterShow();

	//中秋节来了，使用中秋节促销活动
	cout << "乙国人：";
	waiter.Waiter(CountryYi);
	waiter.WaiterShow();

	//端午节来了，使用圣诞节促销活动
	cout << "丙国人：";
	waiter.Waiter(CountryBin);
	waiter.WaiterShow();

	system("pause");
	return 0;
}


/*************************************************************
	抽象工厂模式

在上文提到的最易懂的设计模式系列解析：工厂方法模式，发现工厂方法模式存在一个严重的问题：一个具体工厂只能创建一类产品
而在实际过程中，一个工厂往往需要生产多类产品。为了解决上述的问题，我们又使用了一种新的设计模式：抽象工厂模式。

抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；
具体的工厂负责实现具体的产品实例。
抽象工厂模式与工厂方法模式最大的区别: 抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类。

允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。

步骤1： 创建抽象工厂类，定义具体工厂的公共接口；
步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；
步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；
步骤4： 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
步骤5：	创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
步骤6：	客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例


背景：小成有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；
	  随着客户需求的变化，A厂所在地的客户需要也模具类产品，B厂所在地的客户也需要容器类产品；
冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂
解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。

**************************************************************/

#include <iostream>
#include "Factory.h"
using namespace std;

//步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例
int main()
{
	//生产工作流程
	Factory *mFactoryA = new FactoryA();
	Factory *mFactoryB = new FactoryB();
	
	std::cout << "A厂原本负责生产机械臂，型号为A型机械臂: " << std::endl;
	mFactoryA->ManufactureRobotArm()->Show();
	std::cout << "A厂新增加计算机生产产线，型号为A型计算机: " << std::endl;
	mFactoryA->ManufactureComputer()->Show();

	std::cout << std::endl;

	std::cout << "B厂原本负责生产计算机，型号为B型计算机: " << std::endl;
	mFactoryB->ManufactureComputer()->Show();
	std::cout << "B厂新增加机械臂生产产线，型号为B型机械臂: " << std::endl;
	mFactoryB->ManufactureRobotArm()->Show();

	system("pause");
	return 0;
}